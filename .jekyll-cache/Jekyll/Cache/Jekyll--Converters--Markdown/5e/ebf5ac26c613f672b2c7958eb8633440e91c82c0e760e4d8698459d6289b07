I"Ó=<h1 id="regex-operations">Regex Operations</h1>

<p>Regex operations in Pip use the Pattern data type.</p>

<p>Patterns are delimited by <code class="language-plaintext highlighter-rouge">`</code> (backticks).</p>

<p>Backticks within the Pattern can be escaped using backslash, as can literal backslashes. Regexes are basically Python flavor with a few add-ons. Any legal Python regex is a legal Pip regex (as long as backticks and <code class="language-plaintext highlighter-rouge">&amp;</code> are escaped) and will behave the same way.</p>

<h2 id="differences-between-python-and-pip">Differences between Python and Pip</h2>

<ul>
  <li>Pip Patterns are used both as regexes and as regex replacement strings.</li>
  <li>In addition to back-references (e.g. <code class="language-plaintext highlighter-rouge">\1</code>), Pip replacement Patterns can contain <code class="language-plaintext highlighter-rouge">&amp;</code>, which corresponds to the entire match (as in sed et al.).</li>
  <li>Many Pip regex operations set special variables similar to the ones in Perl, rather than the Python strategy of returning a match object encapsulating that information.</li>
</ul>

<h2 id="predefined-pattern-variables">Predefined Pattern variables</h2>

<p>Some common regexes are available as predefined variables:</p>

<table>
  <thead>
    <tr>
      <th>Variable</th>
      <th>Value</th>
      <th>Mnemonic</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">w</code></td>
      <td><code class="language-plaintext highlighter-rouge">\s+</code></td>
      <td>Whitespace</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">XA</code></td>
      <td><code class="language-plaintext highlighter-rouge">[A-Za-z]</code></td>
      <td>regeX Alpha</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">XC</code></td>
      <td><code class="language-plaintext highlighter-rouge">[bcdfghjklmnpqrstvwxyz]</code></td>
      <td>regeX Consonant</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">XD</code></td>
      <td><code class="language-plaintext highlighter-rouge">\d</code></td>
      <td>regeX Digit</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">XI</code></td>
      <td><code class="language-plaintext highlighter-rouge">-?\d+</code></td>
      <td>regeX Integer</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">XL</code></td>
      <td><code class="language-plaintext highlighter-rouge">[a-z]</code></td>
      <td>regeX Lowercase</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">XN</code></td>
      <td><code class="language-plaintext highlighter-rouge">-?\d+(?:\.\d+)?</code></td>
      <td>regeX Number</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">XU</code></td>
      <td><code class="language-plaintext highlighter-rouge">[A-Z]</code></td>
      <td>regeX Uppercase</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">XV</code></td>
      <td><code class="language-plaintext highlighter-rouge">[aeiou]</code></td>
      <td>regeX Vowel</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">XW</code></td>
      <td><code class="language-plaintext highlighter-rouge">\w</code></td>
      <td>regeX Word</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">XX</code></td>
      <td><code class="language-plaintext highlighter-rouge">.</code></td>
      <td>regeX anything</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">XY</code></td>
      <td><code class="language-plaintext highlighter-rouge">[aeiouy]</code></td>
      <td>regeX vowel-or-Y</td>
    </tr>
  </tbody>
</table>

<h2 id="regex-building-operations">Regex-building operations</h2>

<p>The following operators can be used to build regexes:</p>

<h3 id="concatenaterepeat-low-level--x">Concatenate/repeat (low level): <code class="language-plaintext highlighter-rouge">.</code> <code class="language-plaintext highlighter-rouge">X</code></h3>

<p>Usage: <code class="language-plaintext highlighter-rouge">x.s</code> <code class="language-plaintext highlighter-rouge">xXn</code></p>

<p>Both binary operators work the same as with Scalars. They consider only the text of the Pattern, whether it is a regex, a fragment of a regex, or a replacement. Concatenating a Scalar and a Pattern coerces the result to Pattern.</p>

<h3 id="concatenatealternaterepeat-high-level---">Concatenate/alternate/repeat (high level): <code class="language-plaintext highlighter-rouge">+</code> <code class="language-plaintext highlighter-rouge">,</code> <code class="language-plaintext highlighter-rouge">*</code></h3>

<p>Usage: <code class="language-plaintext highlighter-rouge">x+y</code> <code class="language-plaintext highlighter-rouge">x,y</code> <code class="language-plaintext highlighter-rouge">x*n</code></p>

<p><code class="language-plaintext highlighter-rouge">+</code> and <code class="language-plaintext highlighter-rouge">,</code> assume both operands are valid regexes, wrap each in a non-capturing group, and concatenate them, with <code class="language-plaintext highlighter-rouge">,</code> placing a <code class="language-plaintext highlighter-rouge">|</code> in between. <code class="language-plaintext highlighter-rouge">*</code> assumes the first operand is a valid regex, wraps it in a non-capturing group, and appends a repetition construct like <code class="language-plaintext highlighter-rouge">{n}</code>.</p>

<h3 id="convert-to-regex-x">Convert to regex: <code class="language-plaintext highlighter-rouge">X</code></h3>

<p>Usage: <code class="language-plaintext highlighter-rouge">Xs</code></p>

<p>Converts a Scalar to a Pattern, escaping special characters. Given a List or Range, converts to a Pattern that will match any of the items.</p>

<h3 id="repetitiongrouping-k--c">Repetition/grouping: <code class="language-plaintext highlighter-rouge">K</code> <code class="language-plaintext highlighter-rouge">+</code> <code class="language-plaintext highlighter-rouge">C</code></h3>

<p>Usage: <code class="language-plaintext highlighter-rouge">Kx</code></p>

<p><code class="language-plaintext highlighter-rouge">K</code> and <code class="language-plaintext highlighter-rouge">+</code> modify a Pattern with <code class="language-plaintext highlighter-rouge">*</code> or <code class="language-plaintext highlighter-rouge">+</code>, respectively. <code class="language-plaintext highlighter-rouge">C</code> wraps a pattern in a capturing group.</p>

<p>NOTE: <code class="language-plaintext highlighter-rouge">K</code> also works on Scalars and Ranges, converting them to Patterns first. <code class="language-plaintext highlighter-rouge">+</code> and <code class="language-plaintext highlighter-rouge">C</code> only work on Patterns.</p>

<h3 id="set-flags-----a">Set flags: <code class="language-plaintext highlighter-rouge">-</code> <code class="language-plaintext highlighter-rouge">.</code> <code class="language-plaintext highlighter-rouge">,</code> <code class="language-plaintext highlighter-rouge">A</code></h3>

<p>Usage: <code class="language-plaintext highlighter-rouge">-x</code></p>

<p>The unary operators <code class="language-plaintext highlighter-rouge">-</code> <code class="language-plaintext highlighter-rouge">.</code> <code class="language-plaintext highlighter-rouge">,</code> <code class="language-plaintext highlighter-rouge">A</code> set the case-insensitive, dotall, multiline, and ASCII-only regex flags, respectively. See the Python 3 <code class="language-plaintext highlighter-rouge">re</code> docs for more information.</p>

<h2 id="pip-regex-operations">Pip regex operations</h2>

<p>Pip currently supports the following regex operations (with more in the works):</p>

<h3 id="first-match-">First match: <code class="language-plaintext highlighter-rouge">~</code></h3>

<p>Usage: <code class="language-plaintext highlighter-rouge">s~x</code></p>

<p>Returns the first match of Pattern <code class="language-plaintext highlighter-rouge">x</code> in Scalar <code class="language-plaintext highlighter-rouge">s</code>, or nil if no match was found. Can also be used as <code class="language-plaintext highlighter-rouge">x~s</code>.</p>

<h3 id="all-matches-">All matches: <code class="language-plaintext highlighter-rouge">@</code></h3>

<p>Usage: <code class="language-plaintext highlighter-rouge">s@x</code></p>

<p>Returns a List of all non-overlapping matches of Pattern <code class="language-plaintext highlighter-rouge">x</code> in Scalar <code class="language-plaintext highlighter-rouge">s</code>.</p>

<h3 id="find-index-">Find index: <code class="language-plaintext highlighter-rouge">@?</code></h3>

<p>Usage: <code class="language-plaintext highlighter-rouge">s@?x</code></p>

<p>Returns the start index of the first match of Pattern <code class="language-plaintext highlighter-rouge">x</code> in Scalar <code class="language-plaintext highlighter-rouge">s</code>, or nil if no match was found.</p>

<h3 id="find-all-indices-">Find all indices: <code class="language-plaintext highlighter-rouge">@*</code></h3>

<p>Usage: <code class="language-plaintext highlighter-rouge">s@*x</code></p>

<p>Same as <code class="language-plaintext highlighter-rouge">@?</code>, but returns a List of all match indices.</p>

<h3 id="not-inincount-ni-n">Not in/in/count: <code class="language-plaintext highlighter-rouge">NI</code>, <code class="language-plaintext highlighter-rouge">N</code></h3>

<p>Usage: <code class="language-plaintext highlighter-rouge">xNs</code></p>

<p><code class="language-plaintext highlighter-rouge">N</code> returns the number of non-overlapping matches of Pattern <code class="language-plaintext highlighter-rouge">x</code> in Scalar <code class="language-plaintext highlighter-rouge">s</code>. <code class="language-plaintext highlighter-rouge">NI</code> returns <code class="language-plaintext highlighter-rouge">1</code> if the Pattern was not found, <code class="language-plaintext highlighter-rouge">0</code> if it was.</p>

<h3 id="fullmatch-">Fullmatch: <code class="language-plaintext highlighter-rouge">~=</code></h3>

<p>Usage: <code class="language-plaintext highlighter-rouge">x~=s</code></p>

<p>Returns <code class="language-plaintext highlighter-rouge">1</code> if Pattern <code class="language-plaintext highlighter-rouge">x</code> fully matches Scalar <code class="language-plaintext highlighter-rouge">s</code>, <code class="language-plaintext highlighter-rouge">0</code> otherwise. Can be chained with other comparison operators. Can also be used as <code class="language-plaintext highlighter-rouge">s~=x</code>.</p>

<h3 id="replace-r">Replace: <code class="language-plaintext highlighter-rouge">R</code></h3>

<p>Usage: <code class="language-plaintext highlighter-rouge">sRxp</code></p>

<p>Replace each non-overlapping match of Pattern <code class="language-plaintext highlighter-rouge">x</code> in Scalar <code class="language-plaintext highlighter-rouge">s</code> with replacement (Pattern, Scalar or callback function) <code class="language-plaintext highlighter-rouge">p</code>. The arguments passed to a callback function are the entire match (parameter <code class="language-plaintext highlighter-rouge">a</code>) followed by capture groups (parameters <code class="language-plaintext highlighter-rouge">b</code> through <code class="language-plaintext highlighter-rouge">e</code>).</p>

<h3 id="remove-rm">Remove: <code class="language-plaintext highlighter-rouge">RM</code></h3>

<p>Usage: <code class="language-plaintext highlighter-rouge">sRMx</code></p>

<p>Remove each non-overlapping match of Pattern <code class="language-plaintext highlighter-rouge">x</code> from Scalar <code class="language-plaintext highlighter-rouge">s</code>.</p>

<h3 id="striplstriprstrip---">Strip/lstrip/rstrip: <code class="language-plaintext highlighter-rouge">||</code> <code class="language-plaintext highlighter-rouge">|&gt;</code> <code class="language-plaintext highlighter-rouge">&lt;|</code></h3>

<p>Usage: <code class="language-plaintext highlighter-rouge">s||x</code></p>

<p>Strip matches of Pattern <code class="language-plaintext highlighter-rouge">x</code> from the left, right, or both sides of Scalar <code class="language-plaintext highlighter-rouge">s</code>.</p>

<h3 id="split-">Split: <code class="language-plaintext highlighter-rouge">^</code></h3>

<p>Usage: <code class="language-plaintext highlighter-rouge">s^x</code></p>

<p>Split Scalar <code class="language-plaintext highlighter-rouge">s</code> on occurrences of Pattern <code class="language-plaintext highlighter-rouge">x</code>. If <code class="language-plaintext highlighter-rouge">x</code> contains capture groups, they are included in the resulting List.</p>

<h3 id="map-mr">Map: <code class="language-plaintext highlighter-rouge">MR</code></h3>

<p>Usage: <code class="language-plaintext highlighter-rouge">fMRxs</code></p>

<p>Find all matches of Pattern <code class="language-plaintext highlighter-rouge">x</code> in Scalar <code class="language-plaintext highlighter-rouge">s</code> and map function <code class="language-plaintext highlighter-rouge">f</code> to them. The arguments passed to the function are the entire match (parameter <code class="language-plaintext highlighter-rouge">a</code>) followed by capture groups (parameters <code class="language-plaintext highlighter-rouge">b</code> through <code class="language-plaintext highlighter-rouge">e</code>). Can also be used as <code class="language-plaintext highlighter-rouge">sMRxf</code> or <code class="language-plaintext highlighter-rouge">fMRsx</code>.</p>

<h3 id="loop-lr">Loop: <code class="language-plaintext highlighter-rouge">LR</code></h3>

<p>Usage: <code class="language-plaintext highlighter-rouge">LRxs{...}</code></p>

<p>The command version of <code class="language-plaintext highlighter-rouge">MR</code>: loops over all matches of Pattern <code class="language-plaintext highlighter-rouge">x</code> in Scalar <code class="language-plaintext highlighter-rouge">s</code>. Use regex special variables to access match information inside the loop. Can also be used as <code class="language-plaintext highlighter-rouge">LRsx{...}</code>.</p>

<h2 id="match-variables">Match variables</h2>
<p>(see also: <a href="pre-defs">Pre-defined variables.</a>)</p>

<p>The following regex match variables are set every time a match is made by most regex operationsâ€“most usefully, <code class="language-plaintext highlighter-rouge">MR</code>, <code class="language-plaintext highlighter-rouge">LR</code>, and <code class="language-plaintext highlighter-rouge">R</code>:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">$0</code>: entire match</li>
  <li><code class="language-plaintext highlighter-rouge">$1</code>: capture group 1 (and similarly for 2-9)</li>
  <li><code class="language-plaintext highlighter-rouge">$$</code>: list of all capture group contents</li>
  <li><code class="language-plaintext highlighter-rouge">$(</code>: start index of match</li>
  <li><code class="language-plaintext highlighter-rouge">$)</code>: end index of match</li>
  <li><code class="language-plaintext highlighter-rouge">$[</code>: list of start indices of capture groups</li>
  <li><code class="language-plaintext highlighter-rouge">$]</code>: list of end indices of capture groups</li>
  <li><code>$`</code>: the part of the string before the match</li>
  <li><code class="language-plaintext highlighter-rouge">$'</code>: the part of the string after the match</li>
</ul>
:ET
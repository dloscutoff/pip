I"TI<p>Operators are listed in ASCII order. See also: <a href="https://github.com/dloscutoff/pip/blob/master/Documentation/Precedence%20table.md">precedence table</a>. For guaranteed up-to-date information, your best bet is to read the code: there’s a reasonably human-readable precedence table in <code class="language-plaintext highlighter-rouge">operators.py</code>.</p>

<h3 id="meta-operators">Meta-operators</h3>

<p>The following operators change the way other operators are used, when applied on them.</p>

<p><code class="language-plaintext highlighter-rouge">$</code> Fold: occurs before a binary operator; the resulting compound operator is unary, with the same precedence as the original binary operator</p>

<p><code class="language-plaintext highlighter-rouge">*</code> Map: occurs after a unary operator; arity and precedence remain the same</p>

<p><code class="language-plaintext highlighter-rouge">:</code> Modify-assign: occurs after a unary, binary, or ternary operator; the resulting compound operator has the same arity but is right-associative and has the same precedence as <code class="language-plaintext highlighter-rouge">:</code></p>

<h3 id="operators">Operators</h3>

<p><code>!a</code> Logical not</p>

<p><code>a!=b</code> Numeric not equal</p>

<p><code>#a</code> Length</p>

<p><code>a#&lt;b</code> Length less than</p>

<p><code>a#=b</code> Length equal</p>

<p><code>a#&gt;b</code> Length greater than</p>

<p><code>a%b</code> Modulo</p>

<p><code>a&amp;b</code> Logical and (short-circuiting)</p>

<p><code>a\*b</code> Multiplication; if one operand is a Pattern, regex repetition</p>

<p><code>a\*\*b</code> Exponentiation</p>

<p><code>a+b</code> Addition; if both operands are Patterns, regex concatenation</p>

<p><code>+a</code> Cast value as number</p>

<p><code>++a</code> Pre-increment (always comes before operand, never <code class="language-plaintext highlighter-rouge">a++</code>)</p>

<p><code>a,b</code> Range; if both operands are Patterns, regex alternation</p>

<p><code>,a</code> Range from 0 up to; set multiline flag on Pattern</p>

<p><code>a-b</code> Subtraction</p>

<p><code>-a</code> Numeric negation; set case-insensitive flag on Pattern</p>

<p><code>--a</code> Pre-decrement (always comes before operand, never <code class="language-plaintext highlighter-rouge">a--</code>)</p>

<p><code>a.b</code> Concatenation</p>

<p><code>.a</code> Set dotall flag on Pattern; no-op on other data types</p>

<p><code>a/b</code> Division</p>

<p><code>/a</code> Inverse</p>

<p><code>a//b</code> Integer division</p>

<p><code>a:b</code> Assignment</p>

<p><code>a&lt;b</code> Numeric less than</p>

<p><code>a&lt;=b</code> Numeric less than or equal</p>

<p><code>a&lt;&gt;b</code> Group iterable <code class="language-plaintext highlighter-rouge">a</code> into sections of length <code class="language-plaintext highlighter-rouge">b</code>; with negative <code class="language-plaintext highlighter-rouge">b</code>, groups right-to-left</p>

<p><code>a&lt;|b</code> Strip characters in <code class="language-plaintext highlighter-rouge">b</code> from right of <code class="language-plaintext highlighter-rouge">a</code></p>

<p><code>&lt;|a</code> Strip whitespace from right of <code class="language-plaintext highlighter-rouge">a</code></p>

<p><code>a=b</code> Numeric equal</p>

<p><code>a==b</code> Exactly equal</p>

<p><code>a&gt;b</code> Numeric greater than</p>

<p><code>a&gt;=b</code> Numeric greater than or equal</p>

<p><code>a?bc</code> If-then-else operator (short-circuiting)</p>

<p><code>a@b</code> Get item/slice at index</p>

<p><code>@a</code> Get item at index 0</p>

<p><code>a@\*b</code> Find all indices of item in iterable, substring or regex match in Scalar</p>

<p><code>a@&lt;b</code> Slice of iterable left of index</p>

<p><code>@&lt;a</code> Slice of iterable left of index -1 (i.e. all but the last item)</p>

<p><code>a@&gt;b</code> Slice of iterable right of index</p>

<p><code>@&gt;a</code> Slice of iterable right of index 0 (i.e. all but the first item)</p>

<p><code>a@?b</code> Find first index of item in iterable, substring or regex match in Scalar</p>

<p><code>Aa</code> Convert first char of Scalar to ASCII value (or Unicode point); set ASCII-only flag on Pattern</p>

<p><code>ABa</code> Absolute value of number</p>

<p><code>aAEb</code> List <code class="language-plaintext highlighter-rouge">a</code> with element <code class="language-plaintext highlighter-rouge">b</code> appended</p>

<p><code>aALb</code> List <code class="language-plaintext highlighter-rouge">a</code> with List <code class="language-plaintext highlighter-rouge">b</code> appended</p>

<p><code>aATb</code> Arctan2 (with <code class="language-plaintext highlighter-rouge">a</code> being the y-coordinate and <code class="language-plaintext highlighter-rouge">b</code> being the x-coordinate)</p>

<p><code>ATa</code> Arctangent</p>

<p><code>aBAb</code> Bitwise and</p>

<p><code>aBNb</code> Bitwise not</p>

<p><code>aBOb</code> Bitwise or</p>

<p><code>aBXb</code> Bitwise xor</p>

<p><code>Ca</code> Convert ASCII value/Unicode point to character</p>

<p><code>aCBb</code> List of all combinations of <code class="language-plaintext highlighter-rouge">b</code> elements from iterable <code class="language-plaintext highlighter-rouge">a</code></p>

<p><code>aCGb</code> Coordinate grid of <code class="language-plaintext highlighter-rouge">a</code> rows by <code class="language-plaintext highlighter-rouge">b</code> columns</p>

<p><code>CGa</code> Coordinate grid of <code class="language-plaintext highlighter-rouge">a</code> rows by <code class="language-plaintext highlighter-rouge">a</code> columns</p>

<p><code>aCMb</code> Numeric cmp (-1 if less, 0 if equal, 1 if greater)</p>

<p><code>COa</code> Cosine</p>

<p><code>aCPb</code> Cartesian product of two iterables</p>

<p><code>CPa</code> Cartesian product of a List of iterables</p>

<p><code>CSa</code> Cosecant</p>

<p><code>CTa</code> Cotangent</p>

<p><code>aDCb</code> Delete all occurrences of characters in Scalar <code class="language-plaintext highlighter-rouge">b</code> from Scalar <code class="language-plaintext highlighter-rouge">a</code></p>

<p><code>DGa</code> Convert radians to degrees</p>

<p><code>DQa</code> Dequeue item from back of iterable (modifying argument in-place)</p>

<p><code>ENa</code> Enumerate an iterable (gives List of <code class="language-plaintext highlighter-rouge">[index item]</code> Lists)</p>

<p><code>aEQb</code> Alias for binary <code class="language-plaintext highlighter-rouge">Q</code>, kept for backwards compatibility</p>

<p><code>EXa</code> Exponential (base <em>e</em>)</p>

<p><code>EYa</code> Identity matrix (abbreviation from Matlab’s eye() function)</p>

<p><code>aFBb</code> Convert number from given base to decimal integer</p>

<p><code>FBa</code> Convert number from binary to decimal integer</p>

<p><code>aFIb</code> Filter (1st arg is Block, 2nd is List)</p>

<p><code>aGTb</code> String greater than</p>

<p><code>aGEb</code> String greater than or equal</p>

<p><code>aINb</code> Alias for binary <code class="language-plaintext highlighter-rouge">N</code>, kept for backwards compatibility</p>

<p><code>aJb</code> Join iterable on separator</p>

<p><code>Ja</code> Join iterable on empty string</p>

<p><code>aJWb</code> Join iterable on separator and wrap result in separator as well</p>

<p><code>Ka</code> Apply Kleene star (repeat 0 or more times) to a Pattern</p>

<p><code>LCa</code> Convert to lowercase</p>

<p><code>aLTb</code> String less than</p>

<p><code>aLEb</code> String less than or equal</p>

<p><code>LNa</code> Natural logarithm</p>

<p><code>aMb</code> Map Block to iterable, returning List</p>

<p><code>aMCb</code> Map Block <code class="language-plaintext highlighter-rouge">a</code> to each x,y in <code class="language-plaintext highlighter-rouge">b</code>x<code class="language-plaintext highlighter-rouge">b</code> grid of coordinate pairs</p>

<p><code>aMEb</code> Map Block <code class="language-plaintext highlighter-rouge">a</code> to index/value pairs for items in iterable, returning List</p>

<p><code>aMJb</code> Map Block to iterable and join results into Scalar</p>

<p><code>aMMb</code> Map Block to each subitem of iterable, returning List of Lists</p>

<p><code>MNa</code> Min of iterable using numeric comparison</p>

<p><code>aMPb</code> Map Block to consecutive pairs of items from iterable, returning List</p>

<p><code>aMRbc</code> Map Block to each match of regex b in Scalar c</p>

<p><code>aMSb</code> Map Block to iterable and sum results</p>

<p><code>aMUb</code> Map Block to iterable, unpacking each item as function arguments (like Python’s <code class="language-plaintext highlighter-rouge">itertools.starmap</code>); returns List</p>

<p><code>MXa</code> Max of iterable using numeric comparison</p>

<p><code>aMZbc</code> Map Block to two iterables, passing zipped pairs of elements as arguments; returns List</p>

<p><code>aNb</code> In (returns count of occurrences or 0 if none)</p>

<p><code>aNEb</code> String not equal</p>

<p><code>aNIb</code> Not in (returns truth value 0 or 1)</p>

<p><code>Oa</code> Output value and pass through unchanged (same as <code class="language-plaintext highlighter-rouge">P</code> but without trailing newline)</p>

<p><code>aOGb</code> Grid of ones (<code class="language-plaintext highlighter-rouge">a</code> rows by <code class="language-plaintext highlighter-rouge">b</code> columns)</p>

<p><code>OGa</code> Grid of ones (<code class="language-plaintext highlighter-rouge">a</code> rows by <code class="language-plaintext highlighter-rouge">a</code> columns)</p>

<p><code>Pa</code> Print value with newline and pass through unchanged (output format for Lists depends on command-line flags; nil gives no output and also suppresses trailing newline)</p>

<p><code>aPBb</code> Push item to back of iterable (modifying argument in-place)</p>

<p><code>aPEb</code> List <code class="language-plaintext highlighter-rouge">a</code> with element <code class="language-plaintext highlighter-rouge">b</code> prepended</p>

<p><code>PMa</code> List of all permutations of iterable</p>

<p><code>aPKb</code> Pick out item from index <code class="language-plaintext highlighter-rouge">b</code> of iterable <code class="language-plaintext highlighter-rouge">a</code> (modifying <code class="language-plaintext highlighter-rouge">a</code> in-place)</p>

<p><code>POa</code> Pop item from front of iterable (modifying argument in-place)</p>

<p><code>aPUb</code> Push item to front of iterable (modifying argument in-place)</p>

<p><code>PZa</code> Palindromize iterable, appending its reverse but without repeating the central item</p>

<p><code>aQb</code> String equal</p>

<p><code>QPa</code> Quad-palindromize iterable, palindromizing it and also each of its items</p>

<p><code>QRa</code> Quad-reflect iterable, reflecting it and also each of its items</p>

<p><code>aRbc</code> Replace each occurrence in Scalar <code class="language-plaintext highlighter-rouge">a</code> of substring or Pattern <code class="language-plaintext highlighter-rouge">b</code> with replacement <code class="language-plaintext highlighter-rouge">c</code></p>

<p><code>Ra</code> Alias for unary <code class="language-plaintext highlighter-rouge">RV</code></p>

<p><code>aRAbc</code> Replace item in iterable <code class="language-plaintext highlighter-rouge">a</code> at index <code class="language-plaintext highlighter-rouge">b</code> with replacement <code class="language-plaintext highlighter-rouge">c</code></p>

<p><code>RCa</code> Uniformly random choice of single item from iterable</p>

<p><code>RDa</code> Convert degrees to radians</p>

<p><code>RFa</code> Reflect iterable, appending its reverse</p>

<p><code>aRLb</code> Repeat List <code class="language-plaintext highlighter-rouge">a</code> <code class="language-plaintext highlighter-rouge">b</code> times</p>

<p><code>aRMb</code> From Scalar remove substring(s) or regex matches; from List or Range remove item</p>

<p><code>RPa</code> Convert to Pip representation</p>

<p><code>aRRb</code> Randrange from <code class="language-plaintext highlighter-rouge">a</code> to <code class="language-plaintext highlighter-rouge">b</code></p>

<p><code>RRa</code> Randrange from 0 to <code class="language-plaintext highlighter-rouge">a</code></p>

<p><code>aRTb</code> <code class="language-plaintext highlighter-rouge">a</code>th root of <code class="language-plaintext highlighter-rouge">b</code></p>

<p><code>RTa</code> Square root of <code class="language-plaintext highlighter-rouge">a</code></p>

<p><code>RVa</code> Reverse iterable</p>

<p><code>SCa</code> Swap case: <code class="language-plaintext highlighter-rouge">Hello, World!</code> becomes <code class="language-plaintext highlighter-rouge">hELLO, wORLD!</code></p>

<p><code>SEa</code> Secant</p>

<p><code>SGa</code> Sign of number (-1, 0, or 1)</p>

<p><code>SIa</code> Sine</p>

<p><code>aSKb</code> Sort iterable using Block as key function</p>

<p><code>SNa</code> Sort iterable using numeric comparison</p>

<p><code>SSa</code> Sort iterable using string comparison</p>

<p><code>STa</code> Convert to string (for Lists, the format of the result depends on command-line flags)</p>

<p><code>TAa</code> Tangent</p>

<p><code>aTBb</code> Convert decimal integer <code class="language-plaintext highlighter-rouge">a</code> to base <code class="language-plaintext highlighter-rouge">b</code></p>

<p><code>TBa</code> Convert decimal integer <code class="language-plaintext highlighter-rouge">a</code> to binary</p>

<p><code>aTMb</code> Trim Scalar <code class="language-plaintext highlighter-rouge">a</code> by <code class="language-plaintext highlighter-rouge">b</code> characters from front and end (Scalar <code class="language-plaintext highlighter-rouge">b</code> trims same amt on both sides; Range <code class="language-plaintext highlighter-rouge">b</code> trims different amts)</p>

<p><code>TMa</code> Trim first and last characters from Scalar <code class="language-plaintext highlighter-rouge">a</code></p>

<p><code>aTRbc</code> Transliterate <code class="language-plaintext highlighter-rouge">a</code> from characters in <code class="language-plaintext highlighter-rouge">b</code> to those in <code class="language-plaintext highlighter-rouge">c</code> (with <code class="language-plaintext highlighter-rouge">b</code> or <code class="language-plaintext highlighter-rouge">c</code> Scalar, transliterates one letter to another; with <code class="language-plaintext highlighter-rouge">b</code> or <code class="language-plaintext highlighter-rouge">c</code> Range or List of numbers, translates character codes)</p>

<p><code>UCa</code> Convert to UPPERCASE</p>

<p><code>UQa</code> Keep only unique values from iterable</p>

<p><code>aUWb</code> Unweave iterable <code class="language-plaintext highlighter-rouge">a</code> into a List of <code class="language-plaintext highlighter-rouge">b</code> strands</p>

<p><code>UWa</code> Unweave iterable <code class="language-plaintext highlighter-rouge">a</code> into a List of two strands</p>

<p><code>aVb</code> Call Block as function with arglist (equivalent to <code class="language-plaintext highlighter-rouge">a(*b)</code> in Python)</p>

<p><code>Va</code> Evaluate Block in current context, returning value of final expression or nil if there isn’t one</p>

<p><code>aWRb</code> Wrap Scalar or Pattern with a delimiter</p>

<p><code>aWVb</code> Weave two iterables together, alternating their items</p>

<p><code>WVa</code> Weave all subitems in an iterable together</p>

<p><code>aXb</code> Repeat Scalar <code class="language-plaintext highlighter-rouge">a</code> <code class="language-plaintext highlighter-rouge">b</code> times</p>

<p><code>Xa</code> Covert Scalar or List/Range to equivalent regex Pattern (escaping special characters as necessary)</p>

<p><code>Ya</code> Yank value into the variable <code class="language-plaintext highlighter-rouge">y</code> (equivalent to <code class="language-plaintext highlighter-rouge">(y:a)</code>)</p>

<p><code>YOa</code> Output value, then yank it (equivalent to <code class="language-plaintext highlighter-rouge">(y:Oa)</code>)</p>

<p><code>YPa</code> Print value, then yank it (equivalent to <code class="language-plaintext highlighter-rouge">(y:Pa)</code>)</p>

<p><code>aZb</code> Zip two Lists together (clipping to the shorter length)</p>

<p><code>Za</code> Zip a List of Lists together (clipping to the shortest length)</p>

<p><code>aZDb</code> Zip a List of Lists together, filling missing values with default value <code class="language-plaintext highlighter-rouge">b</code></p>

<p><code>ZDa</code> Zip a List of Lists together, filling missing values with nil</p>

<p><code>aZGb</code> Grid of zeros (<code class="language-plaintext highlighter-rouge">a</code> rows by <code class="language-plaintext highlighter-rouge">b</code> columns)</p>

<p><code>ZGa</code> Grid of zeros (<code class="language-plaintext highlighter-rouge">a</code> rows by <code class="language-plaintext highlighter-rouge">a</code> columns)</p>

<p><code>a\\,b</code> Inclusive range</p>

<p><code>\\,a</code> Inclusive range from 1</p>

<p><code>a^b</code> Split Scalar <code class="language-plaintext highlighter-rouge">a</code> on separator <code class="language-plaintext highlighter-rouge">b</code></p>

<p><code>^a</code> Split Scalar <code class="language-plaintext highlighter-rouge">a</code> into List of characters</p>

<p><code>a^@b</code> Split iterable <code class="language-plaintext highlighter-rouge">a</code> at index or List of indices <code class="language-plaintext highlighter-rouge">b</code></p>

<p><code>a|b</code> Logical or (short-circuiting)</p>

<p><code>a|&gt;b</code> Strip characters in <code class="language-plaintext highlighter-rouge">b</code> from left of <code class="language-plaintext highlighter-rouge">a</code></p>

<p><code>|&gt;a</code> Strip whitespace from left of <code class="language-plaintext highlighter-rouge">a</code></p>

<p><code>a||b</code> Strip characters in <code class="language-plaintext highlighter-rouge">b</code> from <code class="language-plaintext highlighter-rouge">a</code></p>

<p><code>||a</code> Strip whitespace from <code class="language-plaintext highlighter-rouge">a</code></p>

<p><code>a~b</code> Find first match of Pattern <code class="language-plaintext highlighter-rouge">a</code> in Scalar <code class="language-plaintext highlighter-rouge">b</code> (reversible)</p>

<p><code>a~=b</code> Test if Pattern <code class="language-plaintext highlighter-rouge">a</code> fully matches Scalar <code class="language-plaintext highlighter-rouge">b</code> (reversible)</p>
:ET